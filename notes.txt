1. Создаем проект с помощью команды cargo new static-server. Эта команда сформерует корневую директорию проекта,
где будут располагаться Cargo.toml, src и так далее. 

2. Сразу загрузим его в GitHub. Перейдем в свой профиль на GitHub и создадим новый репазиторий. 
Введем следующие команды, находясь в корневой директории:
git init
git add .
git commit -m "commit"
git remote add origin git@github.com:NAME/NAME_REPOSITORY.git (ссылку можно скопировать в GitHub)
git branch -M main (переименовываем с master на main)
git push -u origin main
После этого мы должны видеть проект на GitHub

3. Добавим зависимости в Cargo.toml. Нам потребуется HTTP-фреймворк axum, tokio для асинхронности и tower-http.
В разделе [dependencies] введем:
axum = "0.8.4"
tokio = { version = "1.47.0", features = ["full"] }
tower-http = { version = "0.6.6", features = ["fs"] } 
Крейты в Rust спроектированы так, чтобы включать только необходимую функциональность. Именно поэтому мы указали
features для tokio и tower-http. Чтобы использовать дополнительные функции. Например, если мы укажем tokio без 
features, то получим только rt (базовый однопоточный рантайм) и sync (примитивы синхорнизации). Но для данного
проекта понадобятся: rt-multi-thread (Многопоточный runtime), fs (Файловая система), net (Сетевые возможности)
и macros (Макросы). Если все это не указать (не добавить features = full), но попытаться использовать в коде, то
код просто не скомпилируется. Но и перечислять все компоненты неудобно, поэтому проще просто использовать "full".
Это сделано с той целью, чтобы оптимизировать размер, а также уменьшить время компиляции. 

4. Определим структуру проекта. Для начала создадим стстаические файлы, которые и будете передавать наш 
http-сервер. Создадим папку static в корне проекта и поместим туда один html файл (пока этого хватит).
Вся логика же будет в файле main.rs. Структура данного файла:
    a. Импорт необходимх модулей
    b. Главная асинхронная функция main
    c. Настройка сервиса статических файлов 
    d. Создание маршрутизатора 
    e. Запуск сервера 
    f. Обработка graceful shutdown

5. Начнем с импорта необходимых модулей. Как было сказано ранее, нам потребуется 3 инструмента: axum, tokio и 
tower. Помимо того, что мы указали их в качестве зависимостей, их еще нужно импортировать в код. Для этого 
используется ключевое слово "use". Разберем их по порядку:
    1) use axum::{Router, routing::get}; - в данном импорте мы импортируем компоненты из модуля axum. А именно 
два компонента: Router (основной компонент для создания маршрутов) и routing::get (функция для обработки HTTP GET 
запросов). Фигурные скобки испольщуются для того, чтобы объединить эти 2 импорта в одну строку. Без такой 
"компановки" пришлось бы писать:
use axum::Router;
use axum::routing::get;
    2) use tower_http::services::ServeDir; - тут первое, на что нужно обратить внимание, это на запись 
tower_http. В Cargo.toml мы использовали запись с дефисом (tower-http), а в коде Rust используем подчеркивание.
В Cargo.toml крейты пишутся так, как они зарегистрированы в crates.io (в нашем случае tower-http) и большенство
крейтов используют дефис для удобочитаемости. В самом же коде Rust дефисы замменяются на подчеркивания, так как 
в идентификаторах Rust дефис не разрешен. Дефисы автоматически заменяются на подчеркивания. Поэтому в Cargo.toml 
пишем с дефисом, как в crates.io, в уже в самом Rust коде испольщуем подчеркивание. 
Далее разберемся с тем, что такое ServeDir. Это специализированный сервис для обслуживания статических файлов.
    3) use tokio::net::TcpListener; - это импорт асинхронной среды выполнения. А импорт именно TcpListener - это
асинхронный слушатель TCP-соединений. Ровно такой же инструмент есть и в стандартной бибилиотеке 
(std::net::TcpListener), но в стандартной он является синхронным, поэтому нам он не подходит. 
    4) use std::net::SocketAddr; - тут мы видим использование стандартной библиотеки, а значит нам не нужно 
объявлять какие-либо зависимости в Cargo.toml. Тут импортируется структура для представления сетевого адреса 
(IP + порт) и импортируется она из стандартной библиотеки, так как в для этой задачи не требуется асинхронная 
среда.

6. Теперь начнем создавать главную асинхронную функцию main().
Прежде, чем создавать асинхронную функцию, необходимо прописать атрибут #[tokio::main]. Далее создаем функцию 
main() используя запись: async fm main(){...}

7. Теперь настроим наш сервер. Настройка будет производиться с помощью ранее подключенного ServeDir из 
tower-http. Настройка нужна, чтобы при принятии запроса ServeDir сам находил нужный файл, определял его тип, 
а потом правильно отправлял его пользователю. 
Настройка проходит в 3 шага: 
    1) Создаем базовго помощника 
    2) Добавляем опцию для работы с папками
    3) Используем помощника в роутере
Теперь разберемся с каждым пунктом подробнее. Сначала нужно создать нашего помощника. Назоваем его просто 
"static_service". Объявляется переменная через let. И приравнивается к функции new() из модуля ServeDir:
let static_service = ServeDir::new("static");
"static" - это наименование нашей папки, где хранятся наши стстаические файлы (html, фотографии и т.д.)
Эта папка должна лежать рядом с Cargo.toml, а не в src. То есть именно в корне проекта.
Далее используем метод append_index_html_on_directories() для того, чтобы у нас искался файл index.html в папке
static. Если же такого файла нет в папке static, то сервер будет возвращать ошибку 404.
Это делается вот так:
let static_service = static_service.append_index_html_on_directories(true);
true включает эту опцию, false соответственно тоключает. 
Если вдруг в проекте нет папки static и все статичные файлы расположены в корне проекта, то тогда все равно
нужно использовть данную конструкцию, просто вместо ServeDir::new("static") будет использоваться 
ServeDir::new("."). Если же мы храним статичные файлы в другой папке (например "public"), то вместо static нужно
указать public. 
То есть иными словами, конструкция
    let static_service = ServeDir::new("static");
    let static_service = static_service.append_index_html_on_directories(true);
создает помощника и указывает, где искать ему файлы, которые должны быть возвращены пользователю.
Также следует отметить, что 

8. Теперь создадим маршрутизатор. 
Для начала необходимо создать базовый роутер. Роутер - это диспетчер, он обрабатывает адреса:
let app = Router::new();
Мы создали роутер, но он пока что ничего не умеет обрабатывать. Поэтому создадим обработчик. 
Для этого используется метод route():
let app = app.route("/", get(root_handler));
Данная функция принимает 2 параметра: первый - путь. Это наш слеш ("/"), который является URL главной страницы.
Второй - тип запроса. В нашем случае GET. В нее помещаем функцию, котрая будет обрабатывать запрос. Мы на 
данном этапе еще не написали её. Разумеется, как и в прошлом блоке кода, мы можем не использовать затенение, а 
просто перейти на следующую строку и начать писать метод с точки. 
Далее мы прописываем запасной вариант. Который будет подстраховкой на тот случай, если запрос не подошел ни 
под один маршрут (в нашем случае только маршрут "/"):
let app = app.fallback_service(static_service); 
Эту строку также можно писать без той части, что до точки. 


Далее нам необходимо настроить адрес и порт для нашего сервера:
let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
Значение в квадратных скобках - это IP адрес localhost, а 3000 - это порт. Для аналогии можно привести такое 
сравнение: IP это улица, а порт - номер дома. 

Далее создадим слушателя. 
